const { MessageEmbed, Message } = require("discord.js");
const { Error, RangeError } = require("../../errors");
const Util = require("../../util/Util.js");
const ClassFunction = require("../../util/ClassFunction.js");

/**
 * Setup interaction command reaction pages with this class
 */
class InteractionReactionPages {

  constructor(data = {}) {
    this.setup(data);
  }

  setup(data) {
    /**
     * The embed of Discord.JS
     * @type {?array<MessageEmbed>}
     */
    this.embeds = data.embeds || null;
    ClassFunction.EmbedsOptions(data.embeds);

    /**
     * The time duration of this InteractionReactionPages
     * @type {?number}
     */
    this.duration = data.duration || 30000;
    ClassFunction.DurationOptions(data.duration);

    /**
     * The counting of this InteractionReactionPages
     * @type {?boolean}
     */
    this.countPage = data.countPage || true;
    ClassFunction.CountPagesOptions(data.countPage);

    /**
     * The emoji of this InteractionReactionPages
     * @type {?array<string>}
     */
    this.emoji = {
      previous: {
        name: undefined,
        id: undefined
      },
      stop: {
        name: undefined,
        id: undefined
      },
      next: {
        name: undefined,
        id: undefined
      }
    };
    ClassFunction.EmojiOptions(data.emoji, this.emoji);

    /**
     * The currentPage of this InteractionReactionPages
     * @type {?number}
     */
    this.currentPage = 0;
    
    return this;
  }
  
  /**
   * Adds embed to create page
   * @param {string} [embed] Embed option in array
   * @returns {MessageButtonPages[]}
   */
  setEmbeds(embed) {
    ClassFunction.EmbedsOptions(embed);
    
    try {
      this.embeds = embed.map(embeds => new MessageEmbed(embeds));
    } catch(e) {
      throw new Error("INVALID_EMBED");
    }
    return this;
  }
  
  /**
   * Adds duration in this option
   * @param {number} time The time duration
   * @returns {MessageButtonPages}
   */
  setDuration(time) {
    ClassFunction.DurationOptions(time);

    this.duration = time;
    return this;
  }

  /**
   * Adds count page of your embeds
   * @param {boolean} [count=true] Count all of your embeds
   * @returns {MessageButtonPages}
   */
  setCountPage(counting = true) {
    ClassFunction.CountPagesOptions(counting);

    if (counting === false) this.countPage = false;
    else this.countPage = true;
    return this;
  }

  /**
   * Change emoji of the button
   * @param {string} emoji Custom emoji Previous, Stop, Next
   * @returns {MessageButtonPages[]}
   */
  setEmojiReaction(emoji) {
    ClassFunction.EmojiOptions(emoji, this.emoji)
    return this;
  }



  /**
   * Build page button
   * @param {Message} message Syntax with message
   * @returns {Promise<MessageButtonPages>}
   */
  build(interaction) {
    if (!interaction)
      throw new RangeError("REQUIRE", "Interaction", "interaction");
    
    if (interaction && interaction.type !== "APPLICATION_COMMAND")
      throw new RangeError("ASYNC_ERROR", "Interaction");
      
    if (this.countPage === true) this.embeds[0].setFooter(`Page 1 of ${this.embeds.length}`).setTimestamp(Date.now());
    if (this.countPage === false) this.embeds[0];

    Util.Reaction(interaction, this.embeds, null, this.duration, this.countPage, this.currentPage, this.emoji, null, "INTERACTION", "v13");
  }

  /**
   * Data of this class
   * @returns {InteractionReactionPages}
   */
  toJSON() {
    return {
      embeds: this.embeds,
      duration: this.duration,
      countPage: this.countPage,
      emoji: this.emoji && {
        previous: {
          name: this.emoji.previous.name,
          id: this.emoji.previous.id,
        },
        stop: {
          name: this.emoji.stop.name,
          id: this.emoji.stop.id,
        },
        next: {
          name: this.emoji.next.name,
          id: this.emoji.next.id,
        },
      },
    }
  }
}

module.exports = InteractionReactionPages;
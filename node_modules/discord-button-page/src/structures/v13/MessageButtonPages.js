const { MessageEmbed, MessageButton, MessageActionRow, Message } = require("discord.js");
const { MessageButtonStyles, MessageChannelOptions } = require("../../util/Constants.js");
const Util = require("../../util/Util.js");
const ClassFunction = require("../../util/ClassFunction.js");

/**
 * Setup message command button pages with this class
 */
class MessageButtonPages {

  constructor(data = {}) {
    this.setup(data);
  }

  setup(data) {
    /**
     * The embed of Discord.JS
     * @type {?array<MessageEmbed>}
     */
    this.embeds = data.embeds || null;
    ClassFunction.EmbedsOptions(data.embeds);
    
    /**
     * The channel of this MessageButtonPages
     * @type {?string<MessageChannelOptions>}
     */
    this.channel = data.channel || "CHANNEL";
    ClassFunction.ChannelOptions(data.channel);

    /**
     * The message DM of this MessageButtonPages
     * @type {?string}
     */
    this.messageDM = data.messageDM || null;
    ClassFunction.MessageDMOptions(data.messageDM);

    /**
     * The reply mention of this MessageButtonPages
     * @type {?boolean}
     */
    this.replyMention = data.replyMention || true;
    ClassFunction.ReplyMentionOptions(data.replyMention);

    /**
     * The reply of this MessageButtonPages
     * @type {?boolean}
     */
    this.reply = {
      messageReply: data.reply || false,
      mention: this.replyMention || true
    };
    ClassFunction.ReplyOptions(data.reply);

    /**
     * The time duration of this MessageButtonPages
     * @type {?number}
     */
    this.duration = data.duration || 30000;
    ClassFunction.DurationOptions(data.duration);
    

    /**
     * The counting of this MessageButtonPages
     * @type {?boolean}
     */
    this.countPage = data.countPage || true;
    ClassFunction.CountPagesOptions(data.countPage);
    
    /**
     * The label of this MessageButtonPages
     * @type {?array<string>}
     */
    this.label = data.label || null;
    if (data.label) {
      ClassFunction.LabelOptions(data.label);
      this.label = {
        previous: data.label[0] || undefined,
        stop: data.label[1] || undefined,
        next: data.label[2] || undefined
      }
    }
    else {
      this.label = {
        previous: undefined,
        stop: undefined,
        next: undefined
      }
    }
    
    /**
     * The emoji of this MessageButtonPages
     * @type {?array<string>}
     */
    this.emoji = {
      previous: {
        name: undefined,
        id: undefined
      },
      stop: {
        name: undefined,
        id: undefined
      },
      next: {
        name: undefined,
        id: undefined
      }
    };
    ClassFunction.EmojiOptions(data.emoji, this.emoji);

    /**
     * The color of this MessageButtonPages
     * @type {?array<MessageButtonStyles>}
     */
    this.color = data.color || null;
    if (data.color) {
      ClassFunction.ColorOptions(data.color);
      this.color = {
        previous: data.color[0] || "PRIMARY",
        stop: data.color[1] || "DANGER",
        next: data.color [2] || "PRIMARY"
      }
    }
    else {
      this.color = {
        previous: "PRIMARY",
        stop: "DANGER",
        next: "PRIMARY"
      }
    }

    /**
     * The currentPage of this MessageButtonPages
     * @type {?number}
     */
    this.currentPage = 0;

    return this;
  }
  
  /**
   * Adds embed to create page
   * @param {string} [embed] Embed option in array
   * @returns {MessageButtonPages[]}
   */
  setEmbeds(embed) {
    ClassFunction.EmbedsOptions(embed);
    
    try {
      this.embeds = embed.map(embeds => new MessageEmbed(embeds));
    } catch(e) {
      throw new Error("INVALID_EMBED");
    }
    return this;
  }

  /**
   * Sets channel option
   * @param {string} channel Options must be a TextChannel or DMChannel
   * @returns {MessageButtonPages}
   */
  setChannel(channel) {
    Util.verifyString(channel, RangeError, "CHANNEL_TYPE");
    
    ClassFunction.ChannelOptions(channel);
      
    this.channel = String.prototype.toUpperCase.call(channel || "channel");
    return this;
  }

  /**
   * Adds message text when you set to dm channel
   * @param {string} text Options message text
   * @returns {MessageButtonPages}
   */
  setMessageDM(text) {
    ClassFunction.MessageDMOptions(text, this.channel);
      
    this.messageDM = text;
    return this;
  }

  /**
   * Sets reply message
   * @param {boolean} [reply=false] Reply option
   * @param {boolean} mention Reply mention user option
   * @returns {MessageButtonPages}
   */
  setReply(reply = false, { replyMention: mention } = {}) {
    ClassFunction.ReplyOptions(reply);

    if (reply === false) this.reply.messageReply = false;
    else this.reply.messageReply = true;

    if (mention === undefined) mention = true;
    else if (typeof mention !== "boolean")
      throw new RangeError("REPLY_TYPE", "Mention");

    if (mention === false) this.reply.mention = false;
    else this.reply.mention = true;
    return this;
  }
  
  /**
   * Adds duration in this option
   * @param {number} time The time duration
   * @returns {MessageButtonPages}
   */
  setDuration(time) {
    ClassFunction.DurationOptions(time);

    this.duration = time;
    return this;
  }

  /**
   * Adds count page of your embeds
   * @param {boolean} [count=true] Count all of your embeds
   * @returns {MessageButtonPages}
   */
  setCountPage(counting = true) {
    ClassFunction.CountPagesOptions(counting);

    if (counting === false) this.countPage = false;
    else this.countPage = true;
    return this;
  }

  /**
   * Custom label of the button
   * @param {string} label Custom word
   * @returns {MessageButtonPages[]}
   */
  setLabelButton(label) {
    ClassFunction.LabelOptions(label);
    
    if (label[0]) this.label.previous = label[0];
    if (label[1]) this.label.stop = label[1];
    if (label[2]) this.label.next = label[2];
    return this;
  }

  /**
   * Change emoji of the button
   * @param {string} emoji Custom emoji Previous, Stop, Next
   * @returns {MessageButtonPages[]}
   */
  setEmojiButton(emoji) {
    ClassFunction.EmojiOptions(emoji, this.emoji)
    return this;
  }

  /**
   * Change color of button
   * @param {string} color Custom color Previous, Stop, Next
   * @returns {MessageButtonPages[]}
   */
  setColorButton(color) {
    ClassFunction.ColorOptions(color);

    this.color.previous = String.prototype.toUpperCase.call(color[0] || "PRIMARY");
    this.color.stop = String.prototype.toUpperCase.call(color[1] || "DANGER");
    this.color.next = String.prototype.toUpperCase.call(color[2] || "PRIMARY");
    return this;
  }


  /**
   * Build page button
   * @param {Message} message Syntax with message
   * @returns {Promise<MessageButtonPages>}
   */
  build(message) {
    if (!message)
      throw new RangeError("REQUIRE", "Message", "message");
    
    if (message && message.type !== "DEFAULT")
      throw new RangeError("ASYNC_ERROR", "Message");

    if (this.countPage === true) this.embeds[0].setFooter(`Page 1 of ${this.embeds.length}`).setTimestamp(Date.now());
    if (this.countPage === false) this.embeds[0];
    
    let buttonPrevious = new MessageButton().setCustomId("previous").setStyle("SECONDARY").setDisabled();
    let buttonStop = new MessageButton().setCustomId("stop").setStyle(this.color.stop);
    let buttonNext = new MessageButton().setCustomId("next").setStyle(this.color.next);

    if (this.emoji.previous.name === undefined && this.label.previous === undefined) buttonPrevious.setEmoji("⬅️");
    if (this.emoji.stop.name === undefined && this.label.stop === undefined) buttonStop.setEmoji("❎");
    if (this.emoji.next.name === undefined && this.label.next === undefined) buttonNext.setEmoji("➡️");
    
    if (this.emoji.previous.name || this.emoji.previous.id) buttonPrevious.setEmoji(this.emoji.previous.id || this.emoji.previous.name);
    if (this.emoji.stop.name || this.emoji.stop.id) buttonStop.setEmoji(this.emoji.stop.id || this.emoji.stop.name);
    if (this.emoji.next.name || this.emoji.next.id) buttonNext.setEmoji(this.emoji.next.id || this.emoji.next.name);

    if (this.label.previous) buttonPrevious.setLabel(this.label.previous);
    if (this.label.stop) buttonStop.setLabel(this.label.stop);
    if (this.label.next) buttonNext.setLabel(this.label.next);

    const row = new MessageActionRow().addComponents(buttonPrevious, buttonStop, buttonNext);

    if (this.channel === "DM") {

      /* AUTHOR-TEXT + REPLY + MENTION */
      if (this.messageDM && this.reply.messageReply === true && this.reply.mention === true) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "DM", "MESSAGE").then(() => {
          return message.reply({ content: this.messageDM, allowedMentions: { repliedUser: true } });
        }).catch(() => { 
          return message.channel.send("Can't send messages to this user!");
        })
      }

      /* AUTHOR-TEXT + REPLY */
      if (this.messageDM && this.reply.messageReply === true && this.reply.mention !== true) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "DM", "MESSAGE").then(() => {
          return message.reply({ content: this.messageDM, allowedMentions: { repliedUser: false } });
        }).catch(() => { 
          return message.channel.send("Can't send messages to this user!");
        })
      }

      /* AUTHOR-TEXT */
      if (this.messageDM && this.reply.messageReply !== true && this.reply.mention !== true) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "DM", "MESSAGE").then(() => {
          return message.channel.send({ content: this.messageDM });
        }).catch(() => { 
          return message.channel.send("Can't send messages to this user!");
        })
      }

      if (!this.messageDM) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "DM", "MESSAGE").catch(() => { 
          return message.channel.send("Can't send messages to this user!");
        })
      }

    } else if (this.channel === "CHANNEL") {

      /* REPLY + MENTION */
      if (this.reply.messageReply === true && this.reply.mention === true) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "REPLY", "MESSAGE", this.reply.mention);
      }

      /* REPLY */
      if (this.reply.messageReply === true && this.reply.mention !== true) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "REPLY", "MESSAGE", this.reply.mention);
      }

      /* WITHOUT_REPLY */
      if (this.reply.messageReply === false) {
        Util.Button(message, row, this.embeds, null, this.duration, this.countPage, this.currentPage, this.color, "CHANNEL", "MESSAGE");
      }

    }
  }

  /**
   * data of this class
   * @returns {MessageButtonPages}
   */
  toJSON() {
    return {
      embeds: this.embeds,
      channel: this.channel,
      messageDM: this.messageDM,
      replyMention: this.replyMention,
      reply: this.reply,
      duration: this.duration,
      countPage: this.countPage,
      label: this.label && {
        previous: this.label.previous,
        stop: this.label.stop,
        next: this.label.next,
      },
      emoji: this.emoji && {
        previous: {
          name: this.emoji.previous.name,
          id: this.emoji.previous.id,
        },
        stop: {
          name: this.emoji.stop.name,
          id: this.emoji.stop.id,
        },
        next: {
          name: this.emoji.next.name,
          id: this.emoji.next.id,
        },
      },
      color: this.color && {
        previous: this.color.previous,
        stop: this.color.stop,
        next: this.color.next,
      },
    }
  }
}

module.exports = MessageButtonPages;
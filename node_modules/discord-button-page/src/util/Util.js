const { MessageEmbed, MessageButton, MessageActionRow, Message } = require("discord.js");
const { Error, RangeError, TypeError } = require('../errors');

/**
 * Util of discord-button-page NPM
 * @returns {Promise<Util>}
 * @private
 */
class Util extends null {
  /**
   * Check if their a string or not
   * @param {string} data String for check data
   * @param {Error} error Choose type error
   * @returns {data}
   * @private
   */
  static verifyString(
    data,
    error = Error,
    errorMessage = `Expected a string, got ${data} instead.`
  ) {
    if (typeof data !== 'string') throw new error(errorMessage);
    return data;
  }
  
  /**
   * Check if their a string or not
   * @param {string} text Set emoji to know that a emoji or no
   * @returns {RegExpMatchArray}
   * @private
   */
  static parseEmoji(text) {
    if (text.includes('%')) text = decodeURIComponent(text);
    if (!text.includes(':')) return { name: text, id: undefined };
    const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    return match && {name: match[2], id: match[3] || undefined };
  }

  /**
   * Resolves a partial emoji object.
   * @param {string} emoji Emoji identifier to resolve
   * @returns {?RawEmoji}
   * @private
   */
  static resolvePartialEmoji(emoji) {
    if (!emoji) return undefined;
    if (typeof emoji === 'string') return /^\d{17,19}$/.test(emoji) ? { id: emoji } : Util.parseEmoji(emoji);
    const { id, name } = emoji;
    if (!id && !name) return undefined;
    return { id, name };
  }

  /**
   * Check if that emoji name or no
   * @param {string} emoji Verify emoji name & id
   * @returns {emoji}
   * @private
   */
  static isEmoji(emoji) {
    if (typeof emoji === "string") {
      let emojiNameRagex = /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g;
      let emojiIdRagex = /^\d{17,19}$/;
      return emojiNameRagex.test(emoji) || emojiIdRagex.test(emoji);
    } else {
      throw new TypeError("EMOJI: Must be a string");
    }
  }


  /**
   * Util of reaction pages for interaction/message
   * @param {Message} message Message of Discord.JS
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {boolean} reply Replying user
   * @param {number} duration Duration of interaction end
   * @param {boolean} countPage Count all the page
   * @param {number} currentPage Default 0
   * @param {string} emoji Custom emoji reaction
   * @param {string} mode Mode channel / reply
   * @param {string} type Type interaction / message
   * @param {string} version Version 12 / 13
   * @returns {Promise<Reaction>}
   * @private
   */
  static Reaction(message, embed, reply, duration, countPage, currentPage, emoji, mode, type, version) {
    if (type === "INTERACTION") {
      return message.reply({ embeds: [embed[0]], fetchReply: true }).then(msg => {
        Util.reactionFunction(message, msg, embed, duration, countPage, currentPage, emoji, version);
      })
    }
    else if (type === "MESSAGE") {
      if (mode === "CHANNEL") {
        if (version === "v12") {
          return message.channel.send({ embed: embed[0] }).then(msg => {
            Util.reactionFunction(message, msg, embed, duration, countPage, currentPage, emoji, version);
          })
        }
        else if (version === "v13") {
          return message.channel.send({ embeds: [embed[0]] }).then(msg => {
            Util.reactionFunction(message, msg, embed, duration, countPage, currentPage, emoji, version);
          })
        }
      }
      else if (mode === "REPLY") {
        return message.reply({ embeds: [embed[0]], allowedMentions: { repliedUser: reply.mention } }).then(msg => {
          Util.reactionFunction(message, msg, embed, duration, countPage, currentPage, emoji, version);
        })
      }
    }
  }

  /**
   * Function of reaction v12 / v13
   * @param {Message} message Message of Discord.JS
   * @param {Message} msg Index of the message sended
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {number} duration Duration of interaction end
   * @param {boolean} countPage Count all the page
   * @param {number} currentPage Default 0
   * @param {string} emoji Custom emoji reaction
   * @param {string} version Version 12 / 13
   * @returns {Promise<ReactionFunction>}
   * @private
   */
  static reactionFunction(message, msg, embed, duration, countPage, currentPage, emoji, version) {
    msg.react(emoji.stop.name || emoji.stop.id || "❎");
    msg.react(emoji.next.name || emoji.next.id || "➡️");

    const filter = (reaction, user) => !user.bot && user.id;

    let collector;
    if (version === "v12") {
      collector = msg.createReactionCollector(filter, { time: duration });
    }
    else if (version === "v13") {
      collector = msg.createReactionCollector({ filter: filter, time: duration });
    }

    collector.on("collect", async (reaction, user) => {
      if (!msg) throw new Error("SOMETHING_WRONG");

      let previousName = emoji.previous.name || "⬅️";
      let stopName = emoji.stop.name || "❎";
      let nextName = emoji.next.name || "➡️";

      if (reaction.emoji.name === previousName || reaction.emoji.id === emoji.previous.id) {
        if (user === message.author || user === message.user) {
          currentPage--;
          const embed1 = embed[currentPage];

          reactCollect(embed1);
          
          if (version === "v12") {
            msg.edit({ embed: embed1 });
          }
          else if (version === "v13") {
            msg.edit({ embeds: [embed1] });
          }
          if (currentPage <= 0) {
            msg.react(emoji.stop.name || emoji.stop.id || "❎");
            msg.react(emoji.next.name || emoji.next.id || "➡️");
          }
          else if (currentPage <= embed.length) {
            msg.react(emoji.previous.name || emoji.previous.id || "⬅️");
            msg.react(emoji.stop.name || emoji.stop.id || "❎");
            msg.react(emoji.next.name || emoji.next.id || "➡️");
          }
        } else if (user !== message.author || user !== message.user) {
          reaction.users.remove(user.id);
        }
      }
      else if (reaction.emoji.name === stopName || reaction.emoji.id === emoji.stop.id) {
        if (user === message.author || user === message.user) {
          let embed1 = new MessageEmbed().setColor("RED").setDescription('The page has been stoped!').setTimestamp(Date.now());

          reaction.users.remove(user.id);

         if (version === "v12") {
            msg.edit({ embed: embed1 }).then(async x => {
              x.reactions.removeAll();
            });
          }
          else if (version === "v13") {
            msg.edit({ embeds: [embed1] }).then(async x => {
              x.reactions.removeAll();
            });
          }
        } else if (user !== message.author || user !== message.user) {
          reaction.users.remove(user.id);
        }
      }
      else if (reaction.emoji.name === nextName || reaction.emoji.id === emoji.next.id) {
        if (user === message.author || user === message.user) {
          currentPage++;
          const embed1 = embed[currentPage];

          reactCollect(embed1);

          if (version === "v12") {
            msg.edit({ embed: embed1 });
          }
          else if (version === "v13") {
            msg.edit({ embeds: [embed1] });
          }
          if (currentPage >= (embed.length - 1)) {
            msg.react(emoji.previous.name || emoji.previous.id || "⬅️");
            msg.react(emoji.stop.name || emoji.stop.id || "❎");
          }
          else if (currentPage > 0) {
            msg.react(emoji.previous.name || emoji.previous.id || "⬅️");
            msg.react(emoji.stop.name || emoji.stop.id || "❎");
            msg.react(emoji.next.name || emoji.next.id || "➡️");
          }
        } else if (user !== message.author || user !== message.user) {
          reaction.users.remove(user.id);
        }
      }

      function reactCollect(embed1) {
        if (embed1 && typeof embed1 === "string")
          throw new Error("EMBED_ERROR", "string");
        if (embed1 && typeof embed1 === "number")
          throw new Error("EMBED_ERROR", "number");
        if (embed1 && typeof embed1 === "boolean")
          throw new Error("EMBED_ERROR", "boolean");
        
        if (countPage) embed1.setFooter(`Page ${currentPage + 1} of ${embed.length}`).setTimestamp(Date.now());

        msg.reactions.removeAll();
        reaction.users.remove(user.id);
      }
    });

    collector.on("end", async (collected) => {
      await collector.stop();
      const embed1 = embed[currentPage];
      msg.reactions.removeAll();

      if (version === "v12") {
        if (collected.size > 1) {
          return msg.edit({ embed: embed1 });
        }
        else if (collected.size < 1) {
          return msg.edit({ embed: embed1 });
        }
      }
      else if (version === "v13") {
        if (collected.size > 1) {
          return msg.edit({ embeds: [embed1] });
        }
        else if (collected.size < 1) {
          return msg.edit({ embeds: [embed1] });
        }
      }
    });
  }



  /**
   * Util of button pages for interaction/message
   * @param {Message} message Message of Discord.JS
   * @param {object} row Row of button Discord.JS
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {boolean} ephemeral Ephemeral only the user can see
   * @param {number} duration Duration of interaction end
   * @param {boolean} countPage Count all the page
   * @param {number} currentPage Default 0
   * @param {string} color Custom color button
   * @param {string} mode Mode channel / reply
   * @param {string} type Type interaction / message
   * @param {boolean} reply True/false
   * @returns {Promise<Button>}
   * @private
   */
  static Button(message, row, embed, ephemeral, duration, countPage, currentPage, color, mode, type, reply) {
    if (type === "INTERACTION") {
      return message.reply({ embeds: [embed[0]], components: [row], fetchReply: true }).then(msg => {
        Util.buttonFunction(message, msg, embed, duration, countPage, currentPage, color, type);
      })
    }
    else if (type === "MESSAGE") {
      if (mode === "CHANNEL") {
        return message.channel.send({ embeds: [embed[0]], components: [row] }).then(msg => {
          Util.buttonFunction(message, msg, embed, duration, countPage, currentPage, color, type);
        })
      }
      else if (mode === "DM") {
        return message.author.send({ embeds: [embed[0]], components: [row] }).then(msg => {
          Util.buttonFunction(message, msg, embed, duration, countPage, currentPage, color, type);
        })
      }
      else if (mode === "REPLY") {
        return message.reply({ embeds: [embed[0]], components: [row], allowedMentions: { repliedUser: reply } }).then(msg => {
          Util.buttonFunction(message, msg, embed, duration, countPage, currentPage, color, type);
        })
      }
    }
  }

  /**
   * Function of button v13
   * @param {Message} message Message of Discord.JS
   * @param {Message} msg Index of the message sended
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {number} duration Duration of interaction end
   * @param {boolean} countPage Count all the page
   * @param {number} currentPage Default 0
   * @param {string} color Custom color button
   * @param {string} type Type interaction / message
   * @returns {Promise<ButtonFunction_v13>}
   * @private
   */
  static buttonFunction(message, msg, embed, duration, countPage, currentPage, color, type) {
    let userInteraction;
    if (type === "INTERACTION") {
      userInteraction = message.user.id;
    }
    if (type === "MESSAGE") {
      userInteraction = message.author.id;
    }

    const filter = (buttons) => buttons.user.id === userInteraction && buttons.message.id === msg.id;
    const collector = msg.createMessageComponentCollector({ filter: filter, time: duration });

    collector.on("collect", async (button) => {
      if (!msg) throw new Error("SOMETHING_WRONG");

      if (button.customId === "stop") {
        await collector.stop();
        const embed1 = new MessageEmbed().setColor("RED").setDescription('The page has been stoped!').setTimestamp(Date.now());

        Util.interactionStopButton(msg, "SECONDARY");
        return button.update({ embeds: [embed1], components: msg.components });
      }
      else if (button.customId === "previous") currentPage--;
      else if (button.customId === "next") currentPage++;
      
      const embed1 = embed[currentPage];
      
      if (embed1 && typeof embed1 === "string")
        throw new Error("EMBED_ERROR", "string");
      if (embed1 && typeof embed1 === "number")
        throw new Error("EMBED_ERROR", "number");
      if (embed1 && typeof embed1 === "boolean")
        throw new Error("EMBED_ERROR", "boolean");

      if (countPage) embed1.setFooter(`Page ${currentPage + 1} of ${embed.length}`).setTimestamp(Date.now());
      Util.interactionButton(msg, currentPage, embed, "SECONDARY", color);
			msg.components = msg.components;

      return button.update({ embeds: [embed1], components: msg.components });
    });

    collector.on("end", async (collected) => {
      Util.interactionStopButton(msg, "SECONDARY");

      await collector.stop();
      if (collected.size > -1) {
        const embed1 = embed[currentPage];
        
        if (type === "INTERACTION") {
          await message.editReply({ embeds: [embed1], components: msg.components });
        }
        else if (type === "MESSAGE") {
          await msg.edit({ embeds: [embed1], components: msg.components });
        }
      }
    });
  }



  /**
   * Util of button pages for v12
   * @param {Message} message Message of Discord.JS
   * @param {object} row Row of button Discord.JS
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {number} duration Duration of interaction end
   * @param {boolean} countPage Count all the page
   * @param {number} currentPage Default 0
   * @param {string} color Custom color button
   * @param {string} mode Mode channel / reply
   * @param {string} type Type interaction / message
   * @param {boolean} reply True/false
   * @returns {Promise<Button_v12>}
   * @private
   */
  static Button_v12(message, row, embed, duration, countPage, currentPage, color, mode) {
    if (mode === "CHANNEL") {
      return message.channel.send({ embed: embed[0], component: row }).then(msg => {
        Util.buttonFunction_v12(message, msg, embed, duration, countPage, currentPage, color);
      })
    }
    else if (mode === "DM") {
      return message.author.send({ embed: embed[0], components: row }).then(msg => {
        Util.buttonFunction_v12(message, msg, embed, duration, countPage, currentPage, color);
      })
    }
  }

  /**
   * Function of button v12
   * @param {Message} message Message of Discord.JS
   * @param {Message} msg Index of the message sended
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {number} duration Duration of interaction end
   * @param {boolean} countPage Count all the page
   * @param {number} currentPage Default 0
   * @param {string} color Custom color button
   * @returns {Promise<ButtonFunction_v12>}
   * @private
   */
  static buttonFunction_v12(message, msg, embed, duration, countPage, currentPage, color) {
    const filter = (buttons) => buttons.clicker.user.id === message.author.id;
    let collector;
    try {
      collector = msg.createButtonCollector(filter, { time: duration })
    } catch(e) {
      throw new Error("REQUIRE_DISCORD_BUTTONS_CLIENT", "MessageButtonPages");
    }

    collector.on("collect", async (button) => {
      button.reply.defer();

      if (!msg) throw new Error("SOMETHING_WRONG");

      if (button.id === "stop") {
        await collector.stop();
        const embed1 = new MessageEmbed().setColor("RED").setDescription('The page has been stoped!').setTimestamp(Date.now());

        Util.interactionStopButton(msg, "grey");
        return msg.edit({ embed: embed1, components: msg.components });
      }
      else if (button.id === "previous") currentPage--;
      else if (button.id === "next") currentPage++;
      
      const embed1 = embed[currentPage];
      
      if (embed1 && typeof embed1 === "string")
        throw new Error("EMBED_ERROR", "string");
      if (embed1 && typeof embed1 === "number")
        throw new Error("EMBED_ERROR", "number");
      if (embed1 && typeof embed1 === "boolean")
        throw new Error("EMBED_ERROR", "boolean");

      if (countPage) embed1.setFooter(`Page ${currentPage + 1} of ${embed.length}`).setTimestamp(Date.now());
      Util.interactionButton(msg, currentPage, embed, "grey", color);
			msg.components = msg.components;

      return msg.edit({ embed: embed1, components: msg.components });
    });

    collector.on("end", async (collected) => {
      Util.interactionStopButton(msg, "grey");

      await collector.stop();
      if (collected.size > -1) {
        const embed1 = embed[currentPage];
        await msg.edit({ embed: embed1, components: msg.components });
      }
    });
  }

  /**
   * Function button stop
   * @param {Message} msg Index of the message sended
   * @param {string} color The style of the button
   * @returns {Promise<Button>}
   * @private
   */
  static interactionStopButton(msg, color) {
    for(let message of msg.components) {
      for(let m of message.components) {
        m.setStyle(color).setDisabled(true);
      }
    }
  }

  /**
   * Function button interaction
   * @param {object} componentButton The components of the button message
   * @param {string} currentPage Default 0
   * @param {MessageEmbed} embed Embeds of Discord.JS
   * @param {string} color The style of the button
   * * @param {string} colors The style of the button
   * @returns {Promise<Button>}
   * @private
   */
  static interactionButton(componentButton, currentPage, embed, color, colors) {
    for(let interaction of componentButton.components) {
      if (interaction.components[0]) {
        interaction.components[0].setDisabled(false).setStyle(colors.previous);
      }
      if (interaction.components[2]) {
        interaction.components[2].setDisabled(false).setStyle(colors.next);
      }
    }
    if (!currentPage) componentButton.components[0].components[0].setDisabled(true).setStyle(color);
    else if (currentPage === (embed.length - 1)) componentButton.components[0].components[2].setDisabled(true).setStyle(color);
    else if (embed.length === 1) {
      componentButton.components[0].components[0].setDisabled(true).setStyle(color);
      componentButton.components[0].components[2].setDisabled(true).setStyle(color);
    }
  }
}

module.exports = Util;
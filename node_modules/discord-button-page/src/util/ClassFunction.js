const { MessageEmbed } = require("discord.js");
const { MessageButtonStyles, MessageChannelOptions } = require("../util/Constants.js");
const { Error, RangeError } = require("../errors");
const Util = require("../util/Util.js");

/**
 * The util class function
 * @returns {Promise<ClassFunction>}
 * @private
 */
class ClassFunction extends null {
  /**
   * Function class of embeds options
   * @param {MessageEmbed} data Data of the embeds from Discord.JS
   * @returns {EmbedsOptions<data>}
   * @private
   */
  static EmbedsOptions(data) {
    if (data) {
      if (data && !Array.isArray(data))
        throw new RangeError("EMBED_ARRAY");
      if (data.length < 2)
        throw new RangeError("EMBED_MIN");
    }
    return data;
  }

  /**
   * Function class of ephemeral options
   * @param {boolean} data Data of the ephemeral
   * @returns {EphemeralOptions<data>}
   * @private
   */
  static EphemeralOptions(data) {
    if (data) {
      if (data && typeof data !== "boolean")
        throw new RangeError("INTERACTION_EPHEMERAL_TYPE");
    }
    return data;
  }

  /**
   * Function class of channel options
   * @param {string} data Data of the channel
   * @returns {ChannelOptions<data>}
   * @private
   */
  static ChannelOptions(data) {
    if (data) {
      let Channels_CHECK = MessageChannelOptions[String.prototype.toUpperCase.call(data || "channel")];
      if (!Channels_CHECK || Channels_CHECK === undefined || Channels_CHECK === null)
        throw new RangeError("INVALID_CHANNEL");
    }
    return data;
  }

  /**
   * Function class of message dm options
   * @param {string} data Data of the message
   * @param {string} channel Data of the channel
   * @returns {MessageDMOptions<data, channel>}
   * @private
   */
  static MessageDMOptions(data, channel) {
    if (data) {
      if (channel !== "DM")
        throw new RangeError("DM_CHANNEL");
    
      if (data && typeof data !== "string")
        throw new RangeError("MISSING_TEXT");
    }
    return data;
  }

  /**
   * Function class of reply mention options
   * @param {boolean} data Data of the reply mention user
   * @returns {ReplyMentionOptions<data>}
   * @private
   */
  static ReplyMentionOptions(data) {
    if (data) {
      if (data && typeof data !== "boolean")
        throw new RangeError("REPLY_TYPE", "Mention");
    }
    return data;
  }
  
  /**
   * Function class of reply options
   * @param {boolean} data Data of the reply
   * @returns {ReplyOptions<data>}
   * @private
   */
  static ReplyOptions(data) {
    if (data) {
      if (data && typeof data !== "boolean")
        throw new RangeError("REPLY_TYPE", "Reply");
    }
    return data;
  }

  /**
   * Function class of duration options
   * @param {number} data Data of the duration
   * @returns {DurationOptions<data>}
   * @private
   */
  static DurationOptions(data) {
    if (data) {
      if (data && typeof data !== "number")
        throw new RangeError("DURATION_TIME_TYPE");
      if (data < 5000)
        throw new RangeError("DURATION_TIME_MIN");
    }
    return data;
  }

  /**
   * Function class of count pages options
   * @param {boolean} data Data of the count pages
   * @returns {CountPages<data>}
   * @private
   */
  static CountPagesOptions(data) {
    if (data) {
      if (data && typeof data !== "boolean")
        throw new RangeError("COUNTING_TYPE");
    }
    return data;
  }

  /**
   * Function class of label options
   * @param {array} data Data of the label
   * @returns {LabelOptions<data>}
   * @private
   */
  static LabelOptions(data) {
    if (data) {
      if (!Array.isArray(data))
        throw new RangeError("LABEL_ARRAY", "label")
      
      for (let i = 0; i < 3; i++) {
        if (data[i] && typeof data[i] !== "string")
          Util.verifyString(data[i], RangeError, "LABEL_STRING");

        if (data[i] === undefined) data[i] = 0;
        if (data[i].length > 80)
          throw new RangeError("LABEL_CHARACTERS");
      }

      if (data.length > 3)
        throw new RangeError("LABEL_MAX");
    }
    return data;
  }

  /**
   * Function class of emoji options
   * @param {array} data Data of the emoji want to set
   * @param {object} emoji Data of emoji
   * @returns {EmojiOptions<data, emoji>}
   * @private
   */
  static EmojiOptions(data, emoji) {
    if (data) {
      if (!Array.isArray(data))
        throw new RangeError("EMOJI_ARRAY");
      if (data.length > 3)
        throw new RangeError("EMOJI_MAX");

      /* PREVIOUS */
      if (data[0]) {
        let previous_ID;
        let previous_Name;
        if (Util.resolvePartialEmoji(data[0]) === null) {
          previous_ID = undefined;
          previous_Name = undefined;
        }
        else {
          previous_ID = Util.resolvePartialEmoji(data[0]).id || undefined;
          previous_Name =  Util.resolvePartialEmoji(data[0]).name || undefined;
        }
        
        if (!Util.isEmoji(previous_ID || previous_Name))
          throw new RangeError("EMOJI_INVALID", "previous");
        if (previous_Name === undefined && previous_ID === undefined)
          throw new RangeError("EMOJI_INVALID", "previous");

        emoji.previous.id = Util.resolvePartialEmoji(data[0]).id || undefined;
        emoji.previous.name =  Util.resolvePartialEmoji(data[0]).name || undefined;
      }

      /* STOP */
      if (data[1]) {
        let stop_ID;
        let stop_Name;
        if (Util.resolvePartialEmoji(data[1]) === null) {
          stop_ID = undefined;
          stop_Name = undefined;
        }
        else {
          stop_ID = Util.resolvePartialEmoji(data[1]).id || undefined;
          stop_Name =  Util.resolvePartialEmoji(data[1]).name || undefined;
        }

        if (!Util.isEmoji(stop_ID || stop_Name))
          throw new RangeError("EMOJI_INVALID", "stop");
        if (stop_Name === undefined && stop_ID === undefined)
          throw new RangeError("EMOJI_INVALID", "stop");

        emoji.stop.id = Util.resolvePartialEmoji(data[1]).id || undefined;
        emoji.stop.name =  Util.resolvePartialEmoji(data[1]).name || undefined;
      }

      /* NEXT */
      if (data[2]) {
        let next_ID;
        let next_Name;
        if (Util.resolvePartialEmoji(data[2]) === null) {
          next_ID = undefined;
          next_Name = undefined;
        }
        else {
          next_ID = Util.resolvePartialEmoji(data[2]).id || undefined;
          next_Name =  Util.resolvePartialEmoji(data[2]).name || undefined;
        }
        
        if (!Util.isEmoji(next_ID || next_Name))
          throw new RangeError("EMOJI_INVALID", "next");
        if (next_Name === undefined && next_ID === undefined)
          throw new RangeError("EMOJI_INVALID", "next");

        emoji.next.id = Util.resolvePartialEmoji(data[2]).id || undefined;
        emoji.next.name =  Util.resolvePartialEmoji(data[2]).name || undefined;
      }
    }
    return data;
  }

  /**
   * Function class of color options
   * @param {array} data Data of the color
   * @returns {ColorOptions<data>}
   * @private
   */
  static ColorOptions(data) {
    if (data) {
      if (!Array.isArray(data))
        throw new RangeError("COLOR_ARRAY");
      if (data.length > 3)
        throw new RangeError("COLOR_MAX");

      let PREVIOUS_COLOR_CHECK = MessageButtonStyles[String.prototype.toUpperCase.call(data[0] || "primary")];
      let STOP_COLOR_CHECK = MessageButtonStyles[String.prototype.toUpperCase.call(data[1] || "danger")];
      let NEXT_COLOR_CHECK = MessageButtonStyles[String.prototype.toUpperCase.call(data[2] || "primary")];
      
      /* PREVIOUS */
      if (!PREVIOUS_COLOR_CHECK || PREVIOUS_COLOR_CHECK === undefined)
        throw new TypeError("INVALID_COLOR", "previous");

      /* STOP */
      if (!STOP_COLOR_CHECK || STOP_COLOR_CHECK === undefined)
        throw new TypeError("INVALID_COLOR", "stop");

      /* NEXT */
      if (!NEXT_COLOR_CHECK || NEXT_COLOR_CHECK === undefined)
        throw new TypeError("INVALID_COLOR", "next");
    }
    return data;
  }
}

module.exports = ClassFunction;